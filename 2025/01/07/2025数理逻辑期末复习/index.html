<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2025数理逻辑期末复习 | 祇树给孤独园</title><meta name="author" content="Chunchia Wang"><meta name="copyright" content="Chunchia Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="关于逻辑学 若前提100%正确，结论是否保证 100%正确？ 论证过程是否严密，与“前提是否正确”无关  “前提”来自各个领域，其正确性和“逻辑”本身无关 逻辑学家关心的是：“从某些（假定为真的）论据出发，究竟能不能得到最终的结论”  演绎有效性（非正式定义）：我们称一个推演步骤是有效的当且仅当不存在任何一种可能，令该推演的前提为真且结论为假。同样地，在这种情况下我们称这些前提蕴涵（entails">
<meta property="og:type" content="article">
<meta property="og:title" content="2025数理逻辑期末复习">
<meta property="og:url" content="https://wangchunchia.github.io/2025/01/07/2025%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="祇树给孤独园">
<meta property="og:description" content="关于逻辑学 若前提100%正确，结论是否保证 100%正确？ 论证过程是否严密，与“前提是否正确”无关  “前提”来自各个领域，其正确性和“逻辑”本身无关 逻辑学家关心的是：“从某些（假定为真的）论据出发，究竟能不能得到最终的结论”  演绎有效性（非正式定义）：我们称一个推演步骤是有效的当且仅当不存在任何一种可能，令该推演的前提为真且结论为假。同样地，在这种情况下我们称这些前提蕴涵（entails">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wangchunchia.github.io/image/%E7%AB%A0%E9%B1%BC%E5%93%A5.jpg">
<meta property="article:published_time" content="2025-01-06T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-11T13:28:27.733Z">
<meta property="article:author" content="Chunchia Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wangchunchia.github.io/image/%E7%AB%A0%E9%B1%BC%E5%93%A5.jpg"><link rel="shortcut icon" href="/image/W%E7%8E%8B.svg"><link rel="canonical" href="https://wangchunchia.github.io/2025/01/07/2025%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2025数理逻辑期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-11 21:28:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/%E7%AB%A0%E9%B1%BC%E5%93%A5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/Almond_blossom.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="祇树给孤独园"><span class="site-name">祇树给孤独园</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2025数理逻辑期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-06T16:00:00.000Z" title="发表于 2025-01-07 00:00:00">2025-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-11T13:28:27.733Z" title="更新于 2025-01-11 21:28:27">2025-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2025数理逻辑期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="关于逻辑学">关于逻辑学</h2>
<p>若前提100%正确，结论是否保证 100%正确？
论证过程是否严密，与“前提是否正确”无关</p>
<ol type="1">
<li>“前提”来自各个领域，其正确性和“逻辑”本身无关</li>
<li>逻辑学家关心的是：“从某些（假定为真的）论据出发，究竟能不能得到最终的结论”</li>
</ol>
<p>演绎有效性（非正式定义）：我们称一个推演步骤是有效的当且仅当不存在任何一种可能，令该推演的前提为真且结论为假。同样地，在这种情况下我们称这些前提蕴涵（entails）其结论。即在最弱最弱最弱……（省略无穷次）的情况下，推演的前提为真时，其结论也不可能为假。甚至可以说，前提为真且结论为假的情况是在根本上不自洽的。换句话说，一个有效的推演，其结论一定是前提的必要条件。</p>
<p>一个或多个命题是一致的（consistent），当且仅当在任意可能的情况下，它们都同时为真。</p>
<p>两个命题是等价的（equivalent），当且仅当它们在完全相同的可能情况下才同时为真。</p>
<p>逻辑的目的是系统性地检验论证的有效性：我们称一个推演步骤是逻辑有效的，当且仅当它的有效性仅由其前提与结论中的话题无关词汇决定。对于一个逻辑有效的演绎，我们称其前提逻辑上蕴涵（logically
entails）其结论。</p>
<p>培根（Francis
Bacon）：亚里士多德《工具论》中的那些纯演绎的方法（三段论）不足以发现科学真理,因此需要《新工具》（Novum
Organum Scientiarum）</p>
<p>康德（Immanuel
Kant）：分析命题（主项包含谓项）不提供新知识，后天综合命题讲述经验世界的知识，而哲学、数学知识应该是先天综合命题。</p>
<h2 id="集合">0. 集合</h2>
<p>$ A;t = A {t } $</p>
<p><strong>良序关系</strong></p>
<p>良序：设 (A,≤) 为全序集，如果任意 A 的非空子集都有 ≤-极小元，则称
(A,≤) 为良序集。</p>
<p><strong>自然数的定义</strong></p>
<p>设 <span class="math inline">\(A\)</span> 为任意的集合，我们称 <span
class="math inline">\(A+=A∪{A}\)</span> 为 <span
class="math inline">\(A\)</span> 的后继，<span
class="math inline">\(A\)</span> 为 <span
class="math inline">\(A+\)</span> 的前趋。</p>
<p>自然数的定义：<span class="math inline">\(0=∅,1=0+\)</span>。</p>
<p>无穷公理：所有自然数组成的整体是集合，记为 <span
class="math inline">\(ω\)</span>。</p>
<p><strong>数学归纳法</strong></p>
<p>传递集合：设 <span class="math inline">\(A\)</span> 是一个集合，如果
<span class="math inline">\(A\)</span> 的任意元素都是 <span
class="math inline">\(A\)</span> 的子集，则称 <span
class="math inline">\(A\)</span> 是传递集合。</p>
<p>三歧性：<span class="math inline">\(∀x,y∈A.x∈y∨x=y∨y∈x\)</span>。</p>
<p>对任意自然数 <span class="math inline">\(n,m\)</span> 定义：<span
class="math inline">\(m&lt;n\)</span> 当且仅当 <span
class="math inline">\(m∈n\)</span>，<span
class="math inline">\(m≤n\)</span> 当且仅当 <span
class="math inline">\(m&lt;n\)</span> 或 <span
class="math inline">\(m=n\)</span>。（这一定义在本书的习题中已经被滥用，不仅限于自然数，在序数上都可以使用）</p>
<p><strong>习题 ：</strong>证明设 <span class="math inline">\(A\)</span>
为传递集合，则 <span class="math inline">\(A^+\)</span>
也是传递集合。</p>
<p><strong>习题 ：</strong>证明对任意自然数 <span
class="math inline">\(n\)</span>，都有 <span
class="math inline">\(0=n\)</span> 或 <span
class="math inline">\(0∈n\)</span>。</p>
<p><strong>有穷集合和无穷集合</strong></p>
<p><strong>习题：</strong> 证明 <span
class="math inline">\(ω^{++}\)</span> 与 <span
class="math inline">\(ω\)</span> 等势。</p>
<p><strong>习题：</strong>假设 <span
class="math inline">\(A,B,A_1,B_1\)</span> 为满足如下条件的集合：</p>
<ol type="1">
<li><span class="math inline">\(A∩A_1=∅,B∩B_1=∅\)</span>；</li>
<li><span class="math inline">\(A∼B,A_1∼B_1\)</span>；</li>
</ol>
<p>证明：<span class="math inline">\(A∪A_1∼B∪B_1\)</span>。</p>
<p><strong>习题：</strong>设 <span class="math inline">\(A,B\)</span>
为两个集合，证明：</p>
<ol type="1">
<li><span class="math inline">\(A⪯B\)</span> 当且仅当 <span
class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span> 的某个子集等势。</li>
</ol>
<p><strong>习题：</strong>设 <span class="math inline">\(A,B\)</span>
为两个集合，试证明：</p>
<p>（1）如果 <span class="math inline">\(A\)</span> 有穷，<span
class="math inline">\(B⪯A\)</span>，则 <span
class="math inline">\(B\)</span> 也是有穷集合。</p>
<p><strong>可数集合</strong></p>
<p><strong>习题：</strong>设 <span class="math inline">\(A,B\)</span>
为两个可数集合，且 <span class="math inline">\(A,B\)</span> 不相交，即
<span class="math inline">\(A∩B=∅\)</span>。证明：<span
class="math inline">\(A∪B\)</span> 也是可数的。</p>
<p><strong>习题（不考）：</strong>证明：</p>
<ol type="1">
<li>对任意 <span class="math inline">\(k∈ω\)</span> 有，<span
class="math inline">\(ω_k\)</span> 都是可数集合（约定 <span
class="math inline">\(ω_0={∅},ω_1=ω\)</span>）；</li>
<li>集合 <span class="math inline">\(⋃{ω_k|k∈ω}\)</span> 是可数的。</li>
</ol>
<p><strong>不可数集合（不考）</strong></p>
<p><strong>序数</strong></p>
<p>具有三歧性的传递集合叫做序数。每个自然数都是序数，<span
class="math inline">\(ω\)</span> 是序数。</p>
<p>本书中对序数的定义并不直观，也没有说明序数的用途。此处补充序数的描述：</p>
<p>在数理逻辑中，序数（ordinal numbers）
是一种用于表示集合的“大小”和“顺序类型”的概念，尤其在集合论、公理集合论和模型论中起着重要作用。序数扩展了自然数的概念，可以用来描述无穷集合的大小和结构，起到了将有限和无限统一到同一框架下的作用。</p>
<p>序数是良序集的等价类。直观地，序数可以理解为一种表示“位置”的标签，且这些标签本身是有序的。</p>
<p><strong>习题：</strong>设 <span class="math inline">\(S\)</span>
为序数集合，证明：</p>
<p>（1）如果 <span class="math inline">\(α\)</span> 是 <span
class="math inline">\(S\)</span> 的最大元，则 <span
class="math inline">\(α=⋃S\)</span>；</p>
<p>（2）如果 <span class="math inline">\(S\)</span>
中无最大元，则对任何的 <span class="math inline">\(β\)</span> 属于 <span
class="math inline">\(S\)</span>，有 <span
class="math inline">\(β&lt;⋃S\)</span>。</p>
<p><strong>超穷归纳法</strong></p>
<p>如果 <span class="math inline">\(α\)</span> 存在前趋，称 <span
class="math inline">\(α\)</span>
为后继序数。不是后继序数的非零序数称为极限序数。</p>
<p><strong>习题：</strong>设 <span class="math inline">\(α,β\)</span>
为序数，且 <span class="math inline">\(α≠0\)</span>。</p>
<p>（1）<span class="math inline">\(α\)</span> 是极限序数，当且仅当
<span class="math inline">\(⋃α=α\)</span>；</p>
<p>（2）如果 <span class="math inline">\(β∈α\)</span>，且 <span
class="math inline">\(β\)</span> 是 <span
class="math inline">\(α\)</span> 的最大元，则 <span
class="math inline">\(α=β^+\)</span>。</p>
<p><strong>可数序数</strong></p>
<p>定义 <span class="math inline">\(ω_1=\{α∣α
是可数序数\}\)</span>。<span class="math inline">\(ω_1\)</span>
是序数，且不可数。</p>
<p>定义 <span class="math inline">\(ω_α+1=\{β∣β\ 是序数且\
β⪯ω_α\}\)</span>。</p>
<p><strong>基数</strong></p>
<p>设 <span class="math inline">\(α\)</span> 是序数，如果对于任意的
<span class="math inline">\(β&lt;α\)</span> 都有 <span
class="math inline">\(β≺α\)</span>，则称 <span
class="math inline">\(α\)</span> 是基数。</p>
<p>讲义中对基数的定义十分诡异，我们在这里补充教材中对基数的定义。集合
<span class="math inline">\(A\)</span> 的基数 <span
class="math inline">\(card\ A\)</span> 是与 <span
class="math inline">\(A\)</span>
大小相等的最小序数，基数的意义是用于比较集合的大小：</p>
<p><span class="math inline">\(card\ A=card\ B⟺A∼B\)</span></p>
<p><strong>习题：</strong>设 <span class="math inline">\(α\)</span>
为基数，κ 为集合 是序数且与等势<span class="math inline">\(\{β|β
是序数且与 α 等势\}\)</span> 的最小元。证明：<span
class="math inline">\(κ\)</span> 是基数。</p>
<p><strong>习题：</strong>对任意的 <span
class="math inline">\(α\)</span> 都有，<span
class="math inline">\(α≤ωα\)</span>。</p>
<h2 id="命题逻辑">1. 命题逻辑</h2>
<p>如果能谈论命题和命题的真假，我们应该也能谈论命题“并非”和“并且”的真假。</p>
<p>在逻辑学中，命题逻辑可以看作是一种 “零阶逻辑”
(相比于一阶逻辑和高阶逻辑)，也就是不含任何变量绑定的逻辑。</p>
<h3 id="命题逻辑的语言">1.1 命题逻辑的语言</h3>
<p><strong>合式公式</strong>（Well-Formed Formulas）：</p>
<ol type="1">
<li><p>每个命题符号<span
class="math inline">\(A_i\)</span>都是合式公式（原子公式，atomic
formula）</p></li>
<li><p>若<span class="math inline">\(\alpha\)</span> ，<span
class="math inline">\(\beta\)</span>是合式公式，那么<span
class="math inline">\((¬ \alpha)\)</span>和<span
class="math inline">\((\alpha□ \beta)\)</span>也是合式公式。其中$□ <span
class="math inline">\(是\)</span>∧,∨,→<span
class="math inline">\(和\)</span>↔︎$ 中的一个</p></li>
<li><p>除此以外都不是合式公式。</p></li>
</ol>
<p><strong>习题 ：</strong>证明不存在长度为 2、3、6
的合式公式，但其他任意正整数长度的合式公式都可能存在。</p>
<p><strong>习题 ：</strong>设 <span class="math inline">\(α\)</span>
是一个合式公式，<span class="math inline">\(c\)</span>
是二元连接符（<span
class="math inline">\(∧,∨,→,↔\)</span>）出现的次数，<span
class="math inline">\(s\)</span> 是命题符合出现的次数（例如，若 <span
class="math inline">\(α=(A→(¬A))\)</span>，则 <span
class="math inline">\(c=1,s=2\)</span>）。使用归纳法证明：<span
class="math inline">\(s=c+1\)</span>。</p>
<h3 id="真值指派">1.2 真值指派</h3>
<p>对于命题符号集合 <span class="math inline">\(S\)</span>，真值指派
<span class="math inline">\(v\)</span> 是函数：</p>
<p><span class="math inline">\(v:S\rightarrow{T,F}\)</span></p>
<p>设 <span class="math inline">\(\bar S\)</span> 是由 <span
class="math inline">\(S\)</span> 通过 5
种公式构造运算得到的合式公式的集合，我们将 <span
class="math inline">\(v\)</span> 扩展到 <span class="math inline">\(\bar
v\)</span>：</p>
<p><span class="math inline">\(\bar v: \bar
S\rightarrow{T,F}\)</span></p>
<p>我们称真值指派 <span class="math inline">\(v\)</span>
<strong>满足</strong> <span class="math inline">\(φ\)</span>，当且仅当
<span class="math inline">\(\bar v(φ)=T\)</span>。</p>
<p><strong>重言蕴含</strong>：<span class="math inline">\(Σ⊨τ\)</span>
当且仅当满足 <span class="math inline">\(Σ\)</span>
中每个合式公式的真值指派也满足 <span
class="math inline">\(τ\)</span>。<span
class="math inline">\(\{σ\}⊨τ\)</span> 也记为 <span
class="math inline">\(σ⊨τ\)</span>。</p>
<p><strong>重言式</strong>： <span class="math inline">\(∅⊨τ\)</span>
也记为 <span class="math inline">\(⊨τ\)</span>。</p>
<p><strong>重言等价</strong>：<span class="math inline">\(σ⊨τ\)</span>
并且 <span class="math inline">\(τ⊨σ\)</span>，记为 <span
class="math inline">\(σ⊨=|τ\)</span>。</p>
<p><strong>紧致性定理</strong>：设 <span
class="math inline">\(Σ\)</span> 是合式公式的无限集合，如果对于 <span
class="math inline">\(Σ\)</span> 中的任意有限子集 <span
class="math inline">\(Σ_0\)</span>，都存在一个真值指派满足 <span
class="math inline">\(Σ_0\)</span>
中的每个合式公式，那么，就存在一个真值指派满足 <span
class="math inline">\(Σ\)</span> 的所有合式公式（即，如果 <span
class="math inline">\(Σ\)</span> 的任意有限子集可满足，则 <span
class="math inline">\(Σ\)</span> 可满足）。</p>
<p><strong>习题：</strong>(a) 证明：如果两个真值指派 <span
class="math inline">\(v_1\)</span>,<span
class="math inline">\(v_2\)</span> 与在合式公式 <span
class="math inline">\(α\)</span> 中出现的命题符号的指派是一致的，那么
<span class="math inline">\(\bar v1(α)=\bar
v2(α)\)</span>。（使用归纳法则）。</p>
<p><strong>习题：</strong>（置换）<span
class="math inline">\(α_1\)</span>, <span
class="math inline">\(α_2\)</span>,… 一个合式公式的序列，对每个合式公式
<span class="math inline">\(φ\)</span>，令 <span
class="math inline">\(φ^*\)</span> 是用 <span
class="math inline">\(α_n\)</span>置换 <span
class="math inline">\(A_n\)</span>（对所有 <span
class="math inline">\(n\)</span>）后得到的结果。</p>
<ol type="1">
<li>设 <span class="math inline">\(v\)</span>
是所有命题符号的真值指派，定义 u 为满足 <span
class="math inline">\(u(A_n)=\bar v(α_n)\)</span> 的真值指派，证明 <span
class="math inline">\(\bar u(φ)=v(φ^∗)\)</span> 使用归纳法。</li>
<li>证明如果 <span class="math inline">\(φ\)</span> 是重言式，那么 <span
class="math inline">\(φ^∗\)</span> 也是。（例如，<span
class="math inline">\(((A∧B)↔(B∧A))\)</span>
是一个重言式，因此对任意的合式公式 <span
class="math inline">\(α,β\)</span>，通过置换可得 <span
class="math inline">\(((α∧β)↔(β∧α))\)</span> 是重言式）</li>
</ol>
<h3 id="解析算法">1.3 解析算法</h3>
<p>输入：命题逻辑wff <span class="math inline">\(\varphi\)</span></p>
<p>输出： <span class="math inline">\(\varphi\)</span> 的解析树 <span
class="math inline">\(T\)</span></p>
<p><strong>习题 （不考）：</strong>证明引理 13B 中关于运算 <span
class="math inline">\(ε¬\)</span> 的情形。</p>
<p><strong>习题
：</strong>假定将合式公式的定义修改为去掉其中所有的右括号。对于<span
class="math inline">\(((A∧(¬B))→(C∨D))\)</span>，我们写成：<span
class="math inline">\(((A∧(¬B→(C∨D\)</span>
。证明这种记法具有唯一可读性（即每个合式公式只有一个可能的分解方法）。提示：这种表达式具有的括号数和联结符号数相同。</p>
<h3 id="归纳与递归">1.4 归纳与递归</h3>
<p><strong>递归定义：</strong></p>
<ul>
<li><p>自上而下： <span class="math display">\[S^* = \bigcap \{ S \mid S
\text{ 包含所有命题符号且关于五种公式构造运算封闭} \}\]</span></p></li>
<li><p>自下而上： <span class="math inline">\(S_0 = \{ A_1, \ldots
\}\)</span> <span class="math inline">\(S_i = \{ \neg \alpha \mid \alpha
\in S_{i-1} \} \cup \{ \alpha □ \beta \mid \alpha \in S_{i-1}, \beta \in
S_{i-1}, □ = \land, \lor, \rightarrow, \leftrightarrow \} \cup
S_{i-1}\)</span> <span class="math inline">\(S_* = \bigcup_{n}
S_n\)</span></p></li>
</ul>
<p><span class="math inline">\(S^*=S_*\)</span></p>
<p><strong>关于命题逻辑的归纳原理：</strong></p>
<p>令 $ P() $ 为一个关于命题逻辑的性质。假设：</p>
<ol type="1">
<li>对所有命题符号 $ A_i $，性质 $ P(A_i) $ 成立</li>
<li>对所有的命题公式 $ $ 和 $ $，若 $ P() $ 和 $ P() $ 成立，则 $ P() $
和 $ P(()) $ 也成立，其中 <span class="math inline">\(\Box\)</span> 是
<span class="math inline">\(\land\)</span>、<span
class="math inline">\(\lor\)</span>、<span
class="math inline">\(\rightarrow\)</span> 和 <span
class="math inline">\(\leftrightarrow\)</span> 中的任意一个</li>
</ol>
<p>那么对于所有的命题公式 $ $ 有性质 $ P() $ 成立。</p>
<p><strong>习题 ：</strong>设 <span class="math inline">\(C\)</span>
是由集合 <span class="math inline">\(B={a,b}\)</span> 在二元运算 <span
class="math inline">\(f\)</span> 和一元运算 <span
class="math inline">\(g\)</span> 的作用下生成的。试列出 <span
class="math inline">\(C_2\)</span> 中的所有元素。<span
class="math inline">\(C_3\)</span> 和 <span
class="math inline">\(C_4\)</span> 中各有多少元素</p>
<p><strong>习题 ：</strong>本节中关于要求 <span
class="math inline">\(F\)</span> 仅是 <span
class="math inline">\(U\)</span> 上的关系类的讨论可以进行推广。<span
class="math inline">\(C_∗\)</span> 如前定义，但是如果对于每个 <span
class="math inline">\(i≤n\)</span>，我们有 <span
class="math inline">\(x_i∈B\)</span> 或者对某个 <span
class="math inline">\(R∈F\)</span> 以及某些小于 <span
class="math inline">\(i\)</span> 的数 <span
class="math inline">\(j_1,…,j_k\)</span>有 <span
class="math inline">\(⟨x_{j1},…,x_{jk},x_i⟩∈R\)</span>，那么我们说 <span
class="math inline">\(⟨x_0,,x_1…,x_n⟩\)</span> 是一个构造序列。请给出
<span class="math inline">\(C^∗\)</span> 的正确定义，并证明 <span
class="math inline">\(C^∗=C_∗\)</span>。</p>
<h3 id="命题连接词">1.5 命题连接词</h3>
<p>只用 <span class="math inline">\(\neg, \land, \lor, \rightarrow,
\leftrightarrow\)</span> 五个联结词就可以实现任意 <span
class="math inline">\(n\)</span> 元布尔函数</p>
<p><strong>习题 ：</strong>设 <span class="math inline">\(G\)</span>
是三元布尔函数，定义如下：</p>
<p><span
class="math inline">\(G(F,F,F)=F,G(T,F,F)=T,G(F,F,T)=T,\)</span></p>
<p><span
class="math inline">\(G(T,F,T)=F,G(F,T,F)=T,G(T,T,F)=F,\)</span></p>
<p><span class="math inline">\(G(F,T,T)=F,G(T,T,T)=F.\)</span></p>
<p>（a）给出一个仅使用 <span class="math inline">\(∧,∨,¬\)</span>
的能够实现的合式公式；</p>
<p>（b）给出一个合式公式，其联结词最多出现 5 个。</p>
<p><strong>习题 ：</strong>证明 <span
class="math inline">\(\{⊤,⊥,¬,↔,+\}\)</span>
是不完备的。提示：证明任意使用这些联结词和命题符号 <span
class="math inline">\(A,B\)</span> 的合式公式在 <span
class="math inline">\(\bar v(α)\)</span> 的 4
种可能的取值下有偶数个取值为 <span
class="math inline">\(T\)</span>。说明：另一种方法是使用域 ，<span
class="math inline">\({0，1}\)</span>
上的代数，任意使用这些联结词的可实现的布尔函数具有线性的特性。</p>
<h3 id="紧致性和能行性不考">1.7 紧致性和能行性（不考）</h3>
<h2 id="一阶逻辑">2. 一阶逻辑</h2>
<p>在逻辑学中,
谓词逻辑是在命题逻辑的基础上加入量词得到的逻辑，量词包括全称和存在两个逻辑连接词。根据量词的强大程度，谓词逻辑可以进一步被分类为一阶逻辑、二阶逻辑乃至高阶逻辑等。</p>
<h3 id="一阶语言">2.1 一阶语言</h3>
<p>一阶语言是一类形式语言, 是一阶逻辑使用的语言。
大部分现代数学都基于一阶逻辑（一阶语言包含集合论语言，一切数学都可被嵌入在集合论中）。</p>
<p>表达式是符号的任意有限序列。大多数表达式没有意义，项和合式公式是具有特定意义的表达式。</p>
<p><strong>项</strong>定义为在常数符号和变量之前加上函数符号构成的表达式，如
<span class="math inline">\(fx\)</span>。</p>
<p><strong>原子公式</strong>的做用相当于命题逻辑中的命题符号，原子公式是具有如下形式的表达式：$
Pt_1t_2t_n $</p>
<p>没有联结符号和量词符号的合式公式，项+谓词。</p>
<p><strong>合式公式</strong>（或公式）是指由原子公式通过使用 0
次或多次连接符号和量词符号构成的表达式。</p>
<p>原子公式通过0次或多次联结符号和量词符号构成的表达式</p>
<p><strong>自由变量</strong>是“没有量词约束”的变量。</p>
<h3 id="真值与模型">2.2 真值与模型</h3>
<p>一阶语言的结构 <span class="math inline">\(\mathfrak{A}\)</span>
是一个函数，把一些语法上的符号映射到有实际意义的元素。</p>
<p>形式上，一阶语言的一个结构是一个函数，其定义域为参数的集合，且满足以下条件：</p>
<ol type="1">
<li>全称量词 <span class="math inline">\(∀\)</span></li>
<li>n 元谓词符号 <span class="math inline">\(P\)</span></li>
<li>常数符号 <span class="math inline">\(c\)</span></li>
<li><span class="math inline">\(n\)</span> 元函数符号 <span
class="math inline">\(f\)</span></li>
</ol>
<p>结构的基本思想就是给参数赋予意义。</p>
<p>若句子 <span class="math inline">\(σ\)</span> 在 <span
class="math inline">\(\mathfrak{A}\)</span> 中为真，则称 <span
class="math inline">\(\mathfrak{A}\)</span> 是 <span
class="math inline">\(σ\)</span> 的一个模型，记为 <span
class="math inline">\(⊨ _\mathfrak{A} σ\)</span> 。</p>
<p>对于结构 <span class="math inline">\(\mathfrak{A}\)</span>，函数
<span class="math inline">\(s:V→|\mathfrak{A}|\)</span>
<strong>满足</strong>合式公式 <span class="math inline">\(φ\)</span>
记为 <span class="math inline">\(⊨_\mathfrak{A}\varphi[s]\)</span>。</p>
<p>一阶逻辑中全程量词的语义解释：对于合式公式 <span
class="math inline">\(φ\)</span>，<span
class="math inline">\(⊨_\mathfrak{A}∀xφ[s]\)</span> 当且仅当 <span
class="math inline">\(∀d∈|\mathfrak{A}|\)</span>， <span
class="math inline">\(⊨_\mathfrak{A}φ[s(x|d)]\)</span>。其中 <span
class="math inline">\(s(x|d)\)</span> 是一个函数，其取值在变量 <span
class="math inline">\(x\)</span> 处为 <span
class="math inline">\(d\)</span>，其他取值与 <span
class="math inline">\(s\)</span> 相同。这一定义相当于把全称量词 <span
class="math inline">\(∀\)</span> 从 <span
class="math inline">\(⊨_\mathfrak{A}\)</span>
右侧转移到了左侧，常用于证明带全称量词的命题。</p>
<p><span class="math inline">\(\models_\mathfrak{A}(\varphi \rightarrow
\psi)[s]\)</span> 当且仅当或者<span class="math inline">\(\not\models
_\mathfrak{A}\varphi [s]\)</span> 或者<span
class="math inline">\(\models _\mathfrak{A}\psi
[s]\)</span>或者二者都成立。</p>
<h4 id="逻辑蕴涵">逻辑蕴涵</h4>
<p>合式公式集合 <span class="math display">\[Γ\]</span> 逻辑蕴含合式公式
<span class="math inline">\(\varphi\)</span> 记作 <span
class="math inline">\(Γ⊨φ\)</span>，当且仅当对语言中的每个结构 <span
class="math inline">\(\mathfrak{A}\)</span> 和每个函数 <span
class="math inline">\(s:V→|A|\)</span>，使得 <span
class="math inline">\(\mathfrak{A}\)</span> 以 <span
class="math inline">\(s\)</span> 满足 <span
class="math inline">\(Γ\)</span> 的每个元素时，<span
class="math inline">\(\mathfrak{A}\)</span> 也以 <span
class="math inline">\(s\)</span> 满足 <span
class="math inline">\(φ\)</span>。</p>
<p><span class="math inline">\(⊨\)</span>
在命题逻辑中表示重言蕴含，在一阶语言中表示逻辑蕴含。</p>
<p>这里的逻辑蕴涵使用的（元语言）符号 <span
class="math inline">\(⊨\)</span>
与第二章《命题逻辑》里一模一样。由于一阶逻辑包含
（subsumes）命题逻辑（只需允许0元谓词存在），因此逻辑蕴涵包含重言蕴涵，也更接近我们在第一章《非形式化逻辑》里的定义</p>
<p>下面这段话来自教材：</p>
<blockquote>
<p>逻辑蕴涵的定义与第1章中的重言蕴涵非常相似，但是其复杂性却大大不同。在命题逻辑中想要判定一个合式公式是否是重言式，只需要考虑<strong>有限个真值指派</strong>，其中每一个都是有限函数。对每个真值指派，只要计算
<span
class="math inline">\(v―(α)\)</span>，这可以在有限长的时间内完成。（如前所述，<strong>重言式的集合是可以判定的</strong>）</p>
<p>如果要判定一阶语言中的合式公式是否恒真，则需要考虑<strong>每一个结构
<span
class="math inline">\(\mathfrak{A}\)</span></strong>。（特别地，这需要使用每个非空集合，而每个集合都有很多元素）对于每个结构，还要考虑每个从变量集合
<span class="math inline">\(V\)</span> 到 <span
class="math inline">\(|\mathfrak{A}|\)</span> 的函数 <span
class="math inline">\(s\)</span>。并且对每一个给定的结构 <span
class="math inline">\(\mathfrak{A}\)</span> 和 <span
class="math inline">\(s\)</span>，还需要判定 <span
class="math inline">\(\mathfrak{A}\)</span> 是否以 <span
class="math inline">\(s\)</span> 满足 <span
class="math inline">\(φ\)</span>。如果 <span
class="math inline">\(|\mathfrak{A}|\)</span>
是无限的，其本身就是一个非常复杂的概念。</p>
</blockquote>
<p><strong>习题：</strong>证明：<span
class="math inline">\({∀x(α→β),∀xα}⊨∀xβ\)</span></p>
<p><strong>习题：</strong>证明：如果 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(α\)</span> 中不是自由出现的，那么 <span
class="math inline">\(α⊨∀xα\)</span>。</p>
<p><strong>习题：</strong>设语言具有相等和二元谓词符号 <span
class="math inline">\(P\)</span>。对下面的条件中的每一个，找出一个句子
<span class="math inline">\(σ\)</span> 使得结构 <span
class="math inline">\(\mathfrak{A}\)</span> 是 <span
class="math inline">\(σ\)</span> 的模型，当且仅当条件被满足。</p>
<p>​ (a) <span class="math inline">\(|\mathfrak{A}|\)</span>
中恰好有两个元素。</p>
<p><strong>习题： </strong>全称公式 <span
class="math inline">\((∀_1)\)</span> 是形式为 <span
class="math inline">\(∀x_1 ···x_nθ\)</span> 的公式, 存在 公式 <span
class="math inline">\((∃_1)\)</span> 是形式为 <span
class="math inline">\(∃x_1 ···x_nθ\)</span> 的公式。其中 <span
class="math inline">\(θ\)</span> 是无量词. 设 <span
class="math inline">\(\mathfrak{A}\)</span> 是 <span
class="math inline">\(\mathfrak{B}\)</span> 的子 结构，<span
class="math inline">\(s : V → |\mathfrak{A}|\)</span>.</p>
<p>​ (a) 证明:</p>
<p>如果 <span class="math inline">\(⊨ _\mathfrak{A} ψ[s]\)</span> 且
<span class="math inline">\(ψ\)</span> 是存在公式，那么 <span
class="math inline">\(⊨_\mathfrak{B} ψ[s]\)</span>.</p>
<p>如果 <span class="math inline">\(⊨ _\mathfrak{B}
\varphi[s]\)</span>且 <span class="math inline">\(\varphi\)</span>
是全称公式，那么 <span class="math inline">\(⊨ _\mathfrak{A}
φ[s]\)</span>.</p>
<p><strong>习题： </strong>设语言有等号和二元谓词符号 <span
class="math inline">\(P\)</span>. 考虑两个结构 <span
class="math inline">\((\mathbb{N} ; &lt;)\)</span> 和 <span
class="math inline">\((\mathbb{R}; &lt;)\)</span>:</p>
<p>​ (a) 试找出一个句子，它在一个结构中是真的，在另外一个中是假的.</p>
<p><strong>习题：</strong> 设 <span
class="math inline">\(\mathfrak{A}\)</span> 是结构且 <span
class="math inline">\(h\)</span> 是函数, <span
class="math inline">\(ran\ h = |\mathfrak{A}|\)</span>. 证明存在结构
<span class="math inline">\(\mathfrak{B}\)</span>，使得 <span
class="math inline">\(h\)</span> 是一个从 <span
class="math inline">\(\mathfrak{B}\)</span> 到 <span
class="math inline">\(\mathfrak{A}\)</span> 上的同态。提示: 取 <span
class="math inline">\(|\mathfrak{B}|\)</span> = <span
class="math inline">\(dom\ h\)</span>. 一般地，需要使用选择公理在 <span
class="math inline">\(\mathfrak{B}\)</span> 中定义函数， 除非 <span
class="math inline">\(h\)</span> 是一对一的.</p>
<p>​ 说明: 该结果产生“不含等号的升洛文海–斯科伦定理”(见习题 2.6).
即，不含等号时, 任意一个结构 A 都有任意更高基数的扩充结构 <span
class="math inline">\(\mathfrak{B}\)</span>、使得 <span
class="math inline">\(\mathfrak{A}\)</span> 与 <span
class="math inline">\(\mathfrak{B}\)</span>
是初等等价的，除了相等。除非加入等号，否则这个结论是最强的.</p>
<h3 id="解析算法-1">2.3 解析算法</h3>
<p>项是通过符号函数对变量和常数的运算得到的。定义符号函数 <span
class="math inline">\(K\)</span>，使得对符号 <span
class="math inline">\(s\)</span>，<span
class="math inline">\(K(s)=1−n\)</span>，其中 <span
class="math inline">\(n\)</span> 是项的个数。</p>
<p><strong>习题：</strong>证明对于一个合式公式 <span
class="math inline">\(α\)</span> 的真的初始段 <span
class="math inline">\(α^′\)</span>，<span class="math inline">\(K(α^′)
&lt; 1.\)</span></p>
<p><strong>习题：</strong>设 <span class="math inline">\(ε\)</span>
是包含变量、常数符号和函数符号的表达式。证明：<span
class="math inline">\(ε\)</span> 是项当且仅当 <span
class="math inline">\(K(ε)=1\)</span> 且对 <span
class="math inline">\(ε\)</span> 的任意终段 <span
class="math inline">\(ε^′\)</span>，我们有 <span
class="math inline">\(K(ε^′)&gt;0\)</span>。提示：证明更强一些的结果：如果对
<span class="math inline">\(ε\)</span> 的任意终段 <span
class="math inline">\(ε^′\)</span>，<span
class="math inline">\(K(ε^′)&gt;0\)</span>，那么 <span
class="math inline">\(ε\)</span> 是 <span
class="math inline">\(K(ε)\)</span> 个项的连接。</p>
<h3 id="演绎计算">2.4 演绎计算</h3>
<p><strong>替换、可替换</strong></p>
<p><strong>证明的定义：</strong>从 <span
class="math inline">\(\Gamma\)</span> 到 <span
class="math inline">\(\varphi\)</span> 的证明（推导）是一个有穷的 wff
序列 <span class="math inline">\(\langle \alpha_0, \ldots, \alpha_n
\rangle\)</span>，其中 <span class="math inline">\(\alpha_n\)</span>
就是 <span class="math inline">\(\varphi\)</span> 且对任意 <span
class="math inline">\(k \leq n\)</span> 有：</p>
<ol type="1">
<li><span class="math inline">\(\alpha_k\)</span> 属于 <span
class="math inline">\(\Gamma \cup \Lambda\)</span>（<span
class="math inline">\(\Lambda\)</span> 为公理集）, 或者</li>
<li><span class="math inline">\(\alpha_k\)</span>
是由序列中位于它前面的两个 wff 经过 MP 规则推导而得；即存在 <span
class="math inline">\(i, j \leq k\)</span> 有 <span
class="math inline">\(\alpha_j\)</span> 为 <span
class="math inline">\(\alpha_i \rightarrow \alpha_k\)</span></li>
</ol>
<p>若以上证明存在，我们就说 <span class="math inline">\(\varphi\)</span>
是从 <span class="math inline">\(\Gamma\)</span> 出发可证的（provable,
deducible or derivable）, 或称 <span
class="math inline">\(\varphi\)</span> 是 <span
class="math inline">\(\Gamma\)</span> 中的定理（theorem of <span
class="math inline">\(\Gamma\)</span>）, 记为 <span
class="math inline">\(\Gamma \vdash \varphi\)</span>.</p>
<p><strong>假言推理</strong>（Modus Ponen，又称 MP
规则或直言三段论）：<span class="math inline">\(\frac {α,α→β}
{β}\)</span></p>
<p>逻辑公理的集合<span class="math inline">\(Λ\)</span> ：</p>
<ol type="1">
<li>重言式；</li>
<li><span class="math inline">\(∀xα→α_t^x\)</span>，其中 <span
class="math inline">\(t\)</span> 是 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(α\)</span> 中的替换，即把 <span
class="math inline">\(α\)</span> 中出现的 <span
class="math inline">\(x\)</span> 换成 <span
class="math inline">\(t\)</span>；</li>
<li><span class="math inline">\(∀x(α→β)→(∀xα→∀xβ)\)</span>；</li>
<li><span class="math inline">\(α→∀xα\)</span>，其中 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(α\)</span>
中不是自由出现的（自由出现的意思是无量词限定，例如 <span
class="math inline">\(∀yx+y=2\)</span> 中 <span
class="math inline">\(x\)</span> 是自由出现的，<span
class="math inline">\(y\)</span> 不是）；</li>
<li><span class="math inline">\(x=x\)</span>；</li>
<li><span class="math inline">\(x=y→(α→α^′)\)</span>，其中 <span
class="math inline">\(α\)</span> 是原子的，<span
class="math inline">\(α^′\)</span> 是有限次的将 <span
class="math inline">\(α\)</span> 中的 <span
class="math inline">\(x\)</span> 替换为 <span
class="math inline">\(y\)</span> 得到的。</li>
</ol>
<p>由 <span class="math inline">\(Γ∪Λ\)</span>
和假言推理可以获得的公式集叫做 <span class="math inline">\(Γ\)</span>
的定理集合。</p>
<p><strong>概化定理</strong>：如果 <span
class="math inline">\(Γ⊢φ\)</span> 且 x 不在 <span
class="math inline">\(Γ\)</span> 的任何公式中自由出现，则 <span
class="math inline">\(Γ⊢∀xφ\)</span>。</p>
<p><strong>规则 <span class="math inline">\(T\)</span> </strong>：如果
<span class="math inline">\(Γ⊢α1,…,Γ⊢αn\)</span>，且 <span
class="math inline">\({α1,…,αn}\)</span> 重言蕴含 <span
class="math inline">\(β\)</span> ，那么 <span
class="math inline">\(Γ⊢β\)</span>。</p>
<p><strong>演绎定理</strong>：如果 <span
class="math inline">\(Γ;Γ⊢φ\)</span>，那么 <span
class="math inline">\(Γ⊢(Γ→φ)\)</span>。从右到左叫做演绎，从左到右叫演绎定理。</p>
<p><strong>习题：</strong> (a) 设 <span
class="math inline">\(\mathfrak{A}\)</span> 是结构，且令 <span
class="math inline">\(s:V→|\mathfrak{A}|\)</span>，在基本公式集上定义真值指派
<span class="math inline">\(v\)</span> 如下：</p>
<p><span class="math inline">\(v(α)=T\)</span> iff <span
class="math inline">\(⊨_\mathfrak{A}α[s]\)</span></p>
<p>​ 证明，对于任意公式（基本与否均可），有：<span
class="math inline">\(\bar v(α)=T\)</span> iff <span
class="math inline">\(\ ⊨_\mathfrak{A}α[s]\)</span>。说明:
这个结论说明联结词 ¬与 → 在第二章与在第一章中的含义是一样的</p>
<p>​ (b)如果 <span class="math inline">\(Γ\)</span> 重言蕴含 <span
class="math inline">\(φ\)</span>，则 <span
class="math inline">\(Γ\)</span> 逻辑蕴涵 <span
class="math inline">\(φ\)</span>。</p>
<p><strong>习题：</strong> 设 x 不在 <span
class="math inline">\(α\)</span> 中自由出现，证明 Q2b：<span
class="math inline">\(⊢(α→∃xβ)↔∃x(α→β)\)</span>；在同样的假设下，证明
Q3a：<span class="math inline">\(⊢(∀xβ→α)↔∃x(α→β)\)</span></p>
<p><strong>习题</strong>：（再替换引理）(a) 试证： <span
class="math inline">\((φyx)xy\)</span>
一般不相等，而且以下两种情况均有可能发生：<span
class="math inline">\(x\)</span> 在 <span
class="math inline">\((φyx)xy\)</span> 中的某个位置上出现，而在 <span
class="math inline">\(φ\)</span> 中同样的位置上不出现；或者反过来，<span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(φ\)</span>中的某个位置上出现，而在 <span
class="math inline">\((φyx)xy\)</span> 中同样的位置上不出现。</p>
<p>​ (b)证明：如果 <span class="math inline">\(y\)</span> 不在 <span
class="math inline">\(φ\)</span> 中出现，那么在 <span
class="math inline">\(φyx\)</span> 和 <span
class="math inline">\((φyx)xy=φ\)</span> 中 <span
class="math inline">\(x\)</span> 可替换 <span
class="math inline">\(y\)</span>。提示：对 <span
class="math inline">\(y\)</span> 使用归纳法。</p>
<p><strong>习题（不考）：</strong>证明 Eq3：<span
class="math inline">\(⊢∀x∀y∀z(x=y→y=z→x=z)\)</span></p>
<h3 id="可靠性与完备性理论">2.5 可靠性与完备性理论</h3>
<p><strong>可靠性定理：</strong>如果 <span
class="math inline">\(Γ⊢φ\)</span>，那么 <span
class="math inline">\(Γ⊨φ\)</span>。</p>
<p><strong>引理 25A：</strong>逻辑公理都是恒真的。</p>
<p><strong>完备性定理（哥德尔 1930）：</strong></p>
<ol type="1">
<li>如果 <span class="math inline">\(Γ⊨φ\)</span>，那么 <span
class="math inline">\(Γ⊢φ\)</span>。</li>
<li>任意和谐的公式集都是可满足的。</li>
</ol>
<p><strong>紧致性定理：</strong></p>
<ol type="1">
<li>如果 <span class="math inline">\(Γ⊢φ\)</span>，那么存在某个有限的
<span class="math inline">\(Γ_0⊆Γ\)</span>，有 <span
class="math inline">\(Γ_0⊢φ\)</span>。</li>
<li>如果 <span class="math inline">\(Γ\)</span> 的每个有限子集 <span
class="math inline">\(Γ_0\)</span> 都是可满足的，那么 <span
class="math inline">\(Γ\)</span> 是可满足的。特别地，句子集 <span
class="math inline">\(Σ\)</span>
有模型当且仅当其每个有限子集有模型。</li>
</ol>
<p><strong>可枚举定理：</strong></p>
<p>对合理的语言，恒真（valid）合式公式的集合是能行可枚举的。</p>
<p><strong>定理 26A：</strong>如果句子集合 <span
class="math inline">\(Σ\)</span>
有任意大的计数的有限模型，那么就有一个无限模型。</p>
<p><strong>定理 26C：</strong>对有限语言中的有限结构 <span
class="math inline">\(\mathfrak{A}\)</span>，<span
class="math inline">\(Th  \mathfrak{A}\)</span> 是可判定的。</p>
<p><strong>习题：</strong>（语义规则 EI）假设常数符号 <span
class="math inline">\(c\)</span> 不在 <span
class="math inline">\(φ\)</span>、<span class="math inline">\(ψ\)</span>
和 <span class="math inline">\(Γ\)</span> 中出现，<span
class="math inline">\(Γ;φ_c^x⊨ψ\)</span>，证明：<span
class="math inline">\(Γ;∃xφ⊨ψ\)</span>。（不使用可靠性定理和完备性定理）</p>
<p><strong>习题（不考）：</strong>证明完备性定理 (a) 与 (b)
等价。提示：<span class="math inline">\(Γ⊢φ\)</span> 当且仅当 <span
class="math inline">\(Γ∪{¬φ}\)</span> 是不可满足的，且 <span
class="math inline">\(Δ\)</span> 是可满足的当且仅当 <span
class="math inline">\(Δ⊭⊥\)</span>，其中 Δ
是某个不可满足的、可批驳的公式集，如 <span
class="math inline">\(¬∀xx=x\)</span>。</p>
<p>说明：类似地，可靠性定理也适用于每个可满足的公式集是和谐的。</p>
<p><strong>习题：</strong>设 <span
class="math inline">\(Γ⊢φ\)</span>，且 <span
class="math inline">\(P\)</span> 是不在 <span
class="math inline">\(Γ\)</span> 和 <span
class="math inline">\(φ\)</span> 中出现的谓词符号。是否存在不出现 <span
class="math inline">\(P\)</span> 的从 <span
class="math inline">\(Γ\)</span> 到 <span
class="math inline">\(φ\)</span>
的演绎？提示：这个问题有两种不同的方法。“软”方法使用两个不同的语言，一个含有
<span class="math inline">\(P\)</span>，另一个不含 <span
class="math inline">\(P\)</span>；“硬”方法则考虑是否能够可以从 <span
class="math inline">\(Γ\)</span> 到 <span
class="math inline">\(φ\)</span> 的演绎中消去 <span
class="math inline">\(P\)</span>。</p>
<blockquote>
<p><span class="math inline">\(Γ⊢ϕ\)</span> 意味着 <span
class="math inline">\(Γ⊨ϕ\)</span> 。对于不含 <span
class="math inline">\(P\)</span> 且 <span
class="math inline">\(s:V→|𝔄|\)</span> 的语言的每个结构 <span
class="math inline">\(𝔄\)</span> ，使得 <span
class="math inline">\(⊨_𝔄Γ[s]\)</span> ，考虑含 <span
class="math inline">\(P\)</span> 的语言的对应结构 <span
class="math inline">\(𝔄^′\)</span> ，它通过定义 <span
class="math inline">\(P^𝔄=∅\)</span> 扩展了 <span
class="math inline">\(𝔄\)</span> 。然后 <span
class="math inline">\(⊨_{𝔄^′}Γ[s]\)</span> （因为 <span
class="math inline">\(Γ\)</span> 中没有 wff 使用 P ），因此 <span
class="math inline">\(⊨_{𝔄^′}ϕ[s]\)</span> ，意味着 <span
class="math inline">\(⊨_𝔄ϕ[s^′]\)</span>（出于同样的原因）。因此，不含
<span class="math inline">\(P\)</span> 的语言中的 <span
class="math inline">\(Γ⊨ϕ\)</span> 和 <span
class="math inline">\(Γ⊢ϕ\)</span> 。</p>
</blockquote>
<p><strong>习题：</strong>设 <span
class="math inline">\(Γ={¬∀v1Pv1,Pv2,Pv3,…}\)</span>，<span
class="math inline">\(Γ\)</span> 是否和谐？是否可满足？</p>
<h3 id="理论的模型">2.6 理论的模型</h3>
<p>紧致性定理：</p>
<ol type="1">
<li>如果 <span class="math inline">\(Γ⊢φ\)</span>，那么存在某个有限的
<span class="math inline">\(Γ_0⊆Γ\)</span>，有 <span
class="math inline">\(Γ_0⊢φ\)</span>；</li>
<li>如果 <span class="math inline">\(Γ\)</span> 的每个有限子集 <span
class="math inline">\(Γ_0\)</span> 都是可满足的，那么 <span
class="math inline">\(Γ\)</span> 是可满足的。特别地，句子集 <span
class="math inline">\(Σ\)</span>
有模型当且仅当其每个有限子集有模型。</li>
</ol>
<p><strong>习题
（不考）：</strong>证明下述句子是有限恒真的（即在每个有限结构中是真的）：</p>
<p>(a)<span
class="math inline">\(∃x∃y∃z[(Pxfx→Pxx)∨(Pxy∧Pyz∧¬Pxz)]\)</span></p>
<p><strong>习题：</strong>设 <span class="math inline">\(T_1\)</span> ,
<span class="math inline">\(T_2\)</span> 是同一语言的两个理论，使得<span
class="math inline">\(T_1 ⊆ T_2\)</span>、 <span
class="math inline">\(T_1\)</span>是完备的、 <span
class="math inline">\(T_2\)</span>是可满足的。证明: <span
class="math inline">\(T_1=T_2\)</span></p>
<p><strong>习题 （不考）：</strong>给出与如下公式等价的前束公式</p>
<p>(a)<span class="math inline">\((∃xAx∧∃xBx)→Cx\)</span></p>
<p><strong>习题：</strong>考虑带有二元谓词符号 <span
class="math inline">\(&lt;\)</span> 的语言，设 <span
class="math inline">\(\mathfrak{N}=(\mathbb{N};&lt;)\)</span>
是包含（通常序的）自然数的结构。证明：存在某个初等等价于 <span
class="math inline">\(\mathfrak{N}\)</span> 的 <span
class="math inline">\(\mathfrak{A}\)</span>，使得 <span
class="math inline">\(&lt;^\mathfrak{A}\)</span> 具有降序链。（即在
<span class="math inline">\(|\mathfrak{A}|\)</span> 中存在 <span
class="math inline">\(a_0,a_1,⋯\)</span>，使得对所有 <span
class="math inline">\(i\)</span> 有 <span
class="math inline">\(⟨a_{i+1},a_i⟩∈&lt;^\mathfrak{A}\)</span>。）说明：该习题的目的在于说明在这个语言中无法表达“不存在降序链。”</p>
<p><strong>习题：</strong>设有一个不带函数符号的有限语言，</p>
<p>（b）证明：恒真的 <span class="math inline">\(∀_2\)</span>
句子集是可判定的。（<span class="math inline">\(∀_2\)</span>
公式是指具有形式 <span
class="math inline">\(∀x_1…∀x_m∃y_1…∃y_nθ\)</span>的公式，其中 <span
class="math inline">\(θ\)</span> 是无量词的公式。）</p>
<p>说明：在一阶逻辑中，“判定问题”（Entscheidungs
问题）就是在给定一个公式后判定其是否恒真。由于丘奇定理（3.5
节），这一问题通常是无解的。这个习题给出的是判定问题中的一个可解的情形。</p>
<h3 id="理论之间的解释不考">2.7 理论之间的解释（不考）</h3>
<p><strong>习题：</strong>假设 L0 和 L1 含有相同参量的语言，但 L0
中有一个 n 元函数符号 f 不在 L1中，同时 L1 中有一个 (n+1) 元谓词符号 P
不在 L0 中。证明对于 L0 的任意理论 T，存在一个忠实解释将 T 解释到 L1
上。</p>
<p><strong>习题：</strong>设 L0 是含有等号及二元函数符号 + 和 ⋅
的语言，L1 也一样，只不过用三元谓词符号表示加法和乘法。令
Mi=(N;+,⋅)(i=0,1) 分别是包含自然数和加法、乘法的语言 Li 的结构。证明在
M0 中由 L0 公式定义的任何关系都能在 M1 中由 L1 公式定义。</p>
<h2 id="不可判定性">3. 不可判定性</h2>
<h3 id="数论">3.0 数论</h3>
<p><strong>定理 30A：</strong>设 <span
class="math inline">\(A⊆Th\mathfrak{N}\)</span> 是 <span
class="math inline">\(\mathfrak{N}\)</span> 中取值为真的句子集，且 <span
class="math inline">\(A\)</span> 的哥德尔数集合 <span
class="math inline">\(\{♯α∣α∈A\}\)</span> 是一个在 <span
class="math inline">\(\mathfrak{N}\)</span>
中可定义的集合。则我们可以找到一个在 <span
class="math inline">\(\mathfrak{N}\)</span> 中为真的句子 <span
class="math inline">\(σ\)</span>，但 <span
class="math inline">\(σ\)</span> 不能由 <span
class="math inline">\(A\)</span> 推出。</p>
<p>Q: 定理30A的证明思路。</p>
<p>Q:
定理30A中三元关系R是怎么定义的？其中的符号a,b,c,？其中的推理是如何编码的？</p>
<h3 id="数论的子理论">3.3 数论的子理论</h3>
<p><strong>习题 ：</strong>证明：在结构 <span
class="math inline">\((\mathbb{N};⋅,E)\)</span> 中，我们能够定义加法关系
<span
class="math inline">\(\{⟨m,n,m+n⟩|m,n∈\mathbb{N}\}\)</span>。进一步证明在此结构中
<span class="math inline">\(\{0\}\)</span>，序关系 <span
class="math inline">\(&lt;\)</span>，后继关系 <span
class="math inline">\(\{⟨n,S(n)⟩|n∈\mathbb{N}\}\)</span>
都是可定义的。(说明：如果把结构 <span
class="math inline">\((\mathbb{N};⋅,E)\)</span> 简化为 <span
class="math inline">\((\mathbb{N};E)\)</span>，这个结果还能加强。在此处，乘法关系可以通过指数运算的一个法则:
<span class="math inline">\((d^a)^b=d^{ab}\)</span> 来定义）</p>
<h3 id="叙述题"><strong>叙述题</strong></h3>
<p><strong>1.简叙Goedel定理的证明思路</strong></p>
<p><strong>哥德尔第二不完全性定理（1931）:</strong> 设 <span
class="math inline">\(T\)</span> 是一个足够强的递归可公理化理论，则
<span class="math inline">\(T⊢ConsT\)</span> 当且仅当 <span
class="math inline">\(T\)</span> 是不和谐的。</p>
<p><strong>证明思路：</strong></p>
<p>哥德尔第二不完备定理表明，如果一个足够强大的公理系统是相容的，那么它不能证明它自身的相容性。以下是该定理的证明思路，分为几个关键步骤：</p>
<p>可证明性公式：首先，我们定义一个公式 <span
class="math inline">\(Prb_T(x)\)</span>，它表示“ <span
class="math inline">\(x\)</span> 在系统 <span
class="math inline">\(T\)</span>
中是可证明的”。这个公式通过哥德尔编码来表示公式和证明的过程。</p>
<p>相容性公式：接下来，我们定义系统的相容性公式 <span
class="math inline">\(ConsT\)</span>，它表示“系统 <span
class="math inline">\(T\)</span>
是相容的”，即不存在可证明的矛盾。具体来说，<span
class="math inline">\(ConsT\)</span> 可以表示为 <span
class="math inline">\(¬Prb_T(0=1)\)</span>，即系统 <span
class="math inline">\(T\)</span> 不能证明 <span
class="math inline">\(0=1\)</span>。</p>
<p>不动点引理：利用不动点引理，我们可以构造一个自指命题 <span
class="math inline">\(σ\)</span>，使得 <span
class="math inline">\(σ\)</span> 等价于 <span
class="math inline">\(_T()\)</span>。这个命题 <span
class="math inline">\(σ\)</span> 可以被理解为“我不可证明”。</p>
<p>假设系统证明相容性：假设系统 <span class="math inline">\(T\)</span>
能够证明其相容性，即 <span class="math inline">\(T⊢ConsT\)</span>。根据
<span class="math inline">\(σ\)</span> 的定义，我们有：<span
class="math inline">\(T⊢(σ↔¬Prb_T(σ))\)</span></p>
<p>利用反射性质：通过反射性质，我们可以证明如果 <span
class="math inline">\(T⊢σ\)</span>，那么 <span
class="math inline">\(T⊢Prb_T(σ)\)</span>。然而，根据 <span
class="math inline">\(σ\)</span> 的定义，这会导致矛盾，因为 <span
class="math inline">\(T\)</span> 不能同时证明 <span
class="math inline">\(σ\)</span> 和 <span
class="math inline">\(¬Prb_T(σ)\)</span>。</p>
<p><span class="math inline">\(Löb\)</span> 定理的应用：<span
class="math inline">\(Löb\)</span> 定理指出，如果 <span
class="math inline">\(T\)</span> 证明“<span
class="math inline">\(Prb_T(τ)→τ\)</span>”，那么 <span
class="math inline">\(T\)</span> 证明 <span
class="math inline">\(τ\)</span>。在这个情境下，如果 <span
class="math inline">\(T\)</span> 证明 <span
class="math inline">\(ConsT\)</span>，那么根据 <span
class="math inline">\(Löb\)</span> 定理，<span
class="math inline">\(T\)</span> 会证明 <span
class="math inline">\(¬Prb_T(σ)\)</span>，即 <span
class="math inline">\(ConsT\)</span> 本身。</p>
<p>结论：如果 <span class="math inline">\(T\)</span>
是相容的，它不能证明 <span
class="math inline">\(ConsT\)</span>，因为如果 <span
class="math inline">\(T\)</span> 能证明 <span
class="math inline">\(ConsT\)</span>，那么根据上述推理，<span
class="math inline">\(T\)</span>
会变得不相容。因此，哥德尔第二不完备定理成立：如果 <span
class="math inline">\(T\)</span> 是相容的，它不能证明自身的相容性。</p>
<p>总结：哥德尔第二不完备定理的证明思路是通过构造自指命题 <span
class="math inline">\(σ\)</span>，利用可证明性和相容性的表达，结合反射性质和
<span class="math inline">\(Löb\)</span>
定理，最终得出系统无法证明自身相容性的结论。</p>
<blockquote>
<p>一个基于哥德尔第一不完备定理的更简单的证明思路：</p>
<p>哥德尔第一不完备定理可以简化为对“若公理体系具有一致性，则构造的自指命题
<span class="math inline">\(σ\)</span>
为真”这一命题的否定；哥德尔第二不完备定理可以简化为对“从公理可推出公理体系具有一致性”这一命题的否定。</p>
<p>若“从公理可推出公理体系具有一致性”这一命题成立，则有从公理出发可推出自指命题
<span class="math inline">\(σ\)</span>
为真，这本身就是一个推导出（证明出）<span
class="math inline">\(σ\)</span>
的过程，与第一不完备定理相悖。因此“从公理可推出公理体系具有一致性”这一命题为假。</p>
</blockquote>
<p><strong>2.定理30A的证明思路。</strong></p>
<ol type="1">
<li>利用哥德尔数构造自指句子 <span
class="math inline">\(σ\)</span>；</li>
<li>使用反证法，通过假设推出矛盾以证明假设的反面；</li>
<li>得出结论。</li>
</ol>
<p><strong>3.定理30A中三元关系R是怎么定义的？其中的符号<span
class="math inline">\(a,b,c,\alpha\)</span>分别代表什么？其中的推理是如何编码的？</strong></p>
<p><strong>4.AE公理集有哪些？分别是什么？</strong></p>
<p><strong>5.可表示、可定义是怎么定义的？他们有什么区别？</strong></p>
<p><strong>可定义关系：</strong>设 <span
class="math inline">\(R\)</span> 是 <span
class="math inline">\(\mathbb{N}\)</span> 上的 m 元关系，即 <span
class="math inline">\(R⊆\mathbb{N}^m\)</span>。我们已经知道，公式 <span
class="math inline">\(ρ\)</span>（其中只有 <span
class="math inline">\(v_1,⋯,v_m\)</span> 是自由变元）在 <span
class="math inline">\(\mathfrak{N}\)</span> 中定义 <span
class="math inline">\(R\)</span> 当且仅当对于 <span
class="math inline">\(\mathbb{N}\)</span> 中任意的 <span
class="math inline">\(a_1,⋯,a_m\)</span>，</p>
<p><span
class="math inline">\(⟨a_1,⋯,a_m⟩∈R⟺⊨_\mathfrak{N}ρ[a_1,⋯,a_m]⟺⊨_\mathfrak{N}ρ(S^{a1}0,⋯,S^{am}0)\)</span>.</p>
<p>（后两个条件等价是根据替换引理）我们可以把上述结果写成两个蕴涵式：</p>
<p><span
class="math inline">\(⟨a_1,⋯,a_m⟩∈R⇒⊨_\mathfrak{N}ρ(S^{a_1}0,⋯,S^{a_m}0)⟨a_1,⋯,a_m⟩∉R⇒⊨_\mathfrak{N}¬ρ(S^{a_1}0,⋯,S^{a_m}0)\)</span></p>
<p><strong>可表示关系：</strong>如果在上述两个蕴涵式中，“在 N
中为真”的概念可以被更强的概念“从 AE 中推出”取代，我们称 ρ 在理论 Cn AE
中可以表示 R。</p>
<p><span
class="math inline">\(⟨a_1,⋯,a_m⟩∈R⇒ρ(S^{a_1}0,⋯,S^{a_m}0)∈T⟨a_1,⋯,a_m⟩∉R⇒¬ρ(S^{a_1}0,⋯,S^{a_m}0)∉T\)</span></p>
<p><span class="math inline">\(ρ\)</span> 在理论 <span
class="math inline">\(Th\  \mathfrak{N}\)</span> 中表示 <span
class="math inline">\(R\)</span> 当且仅当 <span
class="math inline">\(ρ\)</span> 在 <span
class="math inline">\(\mathfrak{N}\)</span> 中定义 <span
class="math inline">\(R\)</span>。</p>
<p>一个关系在 <span class="math inline">\(T\)</span>
中是可表示的，当且仅当存在一个公式，在 <span
class="math inline">\(T\)</span> 中表示该关系。</p>
<p><strong>定理 33E</strong> 公式 <span class="math inline">\(ρ\)</span>
在 <span class="math inline">\(Cn A_E\)</span> 中表示关系 R 当且仅当</p>
<ol type="1">
<li><span class="math inline">\(ρ\)</span> 由 <span
class="math inline">\(A_E\)</span> 数字确定</li>
<li><span class="math inline">\(ρ\)</span> 在 <span
class="math inline">\(\mathfrak{N}\)</span> 中定义 <span
class="math inline">\(R\)</span>。</li>
</ol>
<p>“定义”意味着创造了新的概念，而“表示”并不创造新的概念。<span
class="math inline">\(C_n A_E\)</span>
作为一个封闭的理论，无法在其中创造更多的概念，因此使用“表示”这一术语。结构
<span class="math inline">\(\mathfrak{N}\)</span>
本身并不包含句子，因此用“定义”这一术语。</p>
<p><strong>6.可表示函数、弱可表示的定义</strong></p>
<p>可表示函数: 设 <span
class="math inline">\(f:\mathbb{N}^m→\mathbb{N}\)</span> 是自然数上的 m
元函数，公式 <span class="math inline">\(φ\)</span> 中只有 <span
class="math inline">\(v_1,⋯,v_{m+1}\)</span> 是自由变元。我们称 <span
class="math inline">\(φ\)</span>（在 <span class="math inline">\(Cn
A_E\)</span> 中）函数表示 <span
class="math inline">\(f\)</span>，当且仅当对于 <span
class="math inline">\(\mathbb{N}\)</span> 中的每一 <span
class="math inline">\(m\)</span> 元组 <span
class="math inline">\(a_1,⋯,a_m\)</span>，</p>
<p><span
class="math inline">\(A_E⊢∀v_{m+1}[φ(S^{a_1}0,⋯,S^{a_m}0,v_{m+1})↔v_{m+1}=S^{f(a_1,⋯,a_m)}0]\)</span></p>
<p>弱可表示: 考虑递归可枚举集 <span
class="math inline">\(Q\)</span>，其中对于递归 <span
class="math inline">\(R\)</span> : <span
class="math inline">\(a∈Q⇔∃b⟨a,b⟩∈R\)</span></p>
<p>我们知道存在公式 <span class="math inline">\(ρ\)</span> 在 <span
class="math inline">\(Cn\ A_E\)</span> 中表示 <span
class="math inline">\(R\)</span> 。因此，公式 <span
class="math inline">\(∃v_2ρ\)</span> 在 <span
class="math inline">\(N\)</span> 中定义了 <span
class="math inline">\(Q\)</span>。这个公式在 <span
class="math inline">\(Cn\ A_E\)</span> 中不能表示 <span
class="math inline">\(Q\)</span>，除非 <span
class="math inline">\(Q\)</span> 是递归的。但我们说这个公式几乎可以表示
<span class="math inline">\(Q\)</span>。</p>
<p><strong>7.不动点定理的证明思路？</strong></p>
<p>不动点引理：对于只含有自由变元 <span
class="math inline">\(v_1\)</span> 的公式 <span
class="math inline">\(β\)</span> ，我们可以找到句子 <span
class="math inline">\(σ\)</span> 使得</p>
<p><span class="math inline">\(A_E⊢[σ↔β(S^{♯σ}0)].\)</span></p>
<p>我们可以认为 <span class="math inline">\(σ\)</span> 间接地表达 “<span
class="math inline">\(β\)</span> 是真的我。” 当然，实际上 <span
class="math inline">\(σ\)</span>
什么也没说，它只是一些符号串而已。甚至当我们在 <span
class="math inline">\(\mathfrak{N}\)</span>
中把它翻译成自然语言时，它也仅仅是关于一些数字和它们的后继及运算结果的句子。正是因为我们把数字和表达式联系起来，我们才能把
<span class="math inline">\(σ\)</span> 看作一个公式。</p>
<p><strong>8.解释范式定理中符号e,a,k,T_m,k,k’的意思</strong></p>
<p>范式定理（Kleene，1943）</p>
<p>（a）在 <span class="math inline">\(⟨e,a_1,⋯,a_m⟩\)</span> 的值是
<span class="math inline">\([e]_m(a_1,⋯,a_m)\)</span> 的 <span
class="math inline">\((m+1)\)</span> 元部分函数是部分递归函数）</p>
<p>（b）对于每个 <span class="math inline">\(e⩾0\)</span>，<span
class="math inline">\([e]_m\)</span> 是 m 元部分递归函数</p>
<p>（c）对于任意 <span class="math inline">\(m\)</span> 元部分递归函数,
都存在某个 <span class="math inline">\(e\)</span>,
使得这个部分递归函数等于 <span class="math inline">\([e]_m\)</span></p>
<p>在范式定理中，符号 <span class="math inline">\(e,a,k,T_m\)</span>, 和
<span class="math inline">\(k^′\)</span> 的含义如下：</p>
<ol type="1">
<li><span class="math inline">\(e\)</span>:
这是递归函数的索引或编码，通常对应于一个程序或计算过程的标识符。它表示一个递归函数或其对应的程序。</li>
<li><span class="math inline">\(a\)</span>: 这是输入向量，通常表示为
<span
class="math inline">\(a_1,a_2,…,a_m\)</span>，是递归函数的输入参数。</li>
<li><span class="math inline">\(k\)</span>: 这是一个编码，表示从公式
<span class="math inline">\(φ\)</span>
推导出结果的推理过程的哥德尔数。它包含了推理过程和结果的信息。</li>
<li><span class="math inline">\(T_m\)</span>: 这是一个 <span
class="math inline">\((m+2)\)</span> 元关系，包含 <span
class="math inline">\(e,a1,…,a_m,k\)</span>。它定义了计算步骤，表示
<span class="math inline">\(e\)</span>、输入 <span
class="math inline">\(a\)</span> 和编码 <span
class="math inline">\(k\)</span> 之间的关系，其中 <span
class="math inline">\(k\)</span> 编码了从公式 <span
class="math inline">\(φ\)</span> 推导出结果的推理过程。</li>
<li><span class="math inline">\(k^′\)</span>: 这是在 <span
class="math inline">\(k\)</span> 之前的某个值，用于确保 <span
class="math inline">\(k\)</span> 是满足条件的最小值。在最小化操作 <span
class="math inline">\(μk\)</span> 中，<span
class="math inline">\(k^′\)</span> 代表比 k
更小的值，用于检查是否有更小的 <span class="math inline">\(k\)</span>
满足条件。</li>
</ol>
<p>范式定理的核心思想是，对于任意递归函数 <span
class="math inline">\(f\)</span>，存在一个索引 <span
class="math inline">\(e\)</span>，使得 <span
class="math inline">\(f(a_1,…,a_m)\)</span> 可以表示为 <span
class="math inline">\(U(μk(e,a_1,…,a_m,k)∈T_m)\)</span>，其中 <span
class="math inline">\(U(k)\)</span> 提取编码 <span
class="math inline">\(k\)</span>
中的结果部分。通过这些符号和关系，定理描述了递归函数的计算过程和其通用性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wangchunchia.github.io">Chunchia Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wangchunchia.github.io/2025/01/07/2025%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://wangchunchia.github.io/2025/01/07/2025%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangchunchia.github.io" target="_blank">祇树给孤独园</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/image/%E7%AB%A0%E9%B1%BC%E5%93%A5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/11/2025%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="2025软件安全期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2025软件安全期末复习</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/15/2024%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="2024软件系统设计期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2024软件系统设计期末复习</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/%E7%AB%A0%E9%B1%BC%E5%93%A5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chunchia Wang</div><div class="author-info__description">自由而无用</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wangchunchia"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%80%BB%E8%BE%91%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">关于逻辑学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">0. 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91"><span class="toc-number">3.</span> <span class="toc-text">1. 命题逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">1.1 命题逻辑的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E6%8C%87%E6%B4%BE"><span class="toc-number">3.2.</span> <span class="toc-text">1.2 真值指派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">1.3 解析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-number">3.4.</span> <span class="toc-text">1.4 归纳与递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E8%BF%9E%E6%8E%A5%E8%AF%8D"><span class="toc-number">3.5.</span> <span class="toc-text">1.5 命题连接词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A7%E8%87%B4%E6%80%A7%E5%92%8C%E8%83%BD%E8%A1%8C%E6%80%A7%E4%B8%8D%E8%80%83"><span class="toc-number">3.6.</span> <span class="toc-text">1.7 紧致性和能行性（不考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91"><span class="toc-number">4.</span> <span class="toc-text">2. 一阶逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E8%AF%AD%E8%A8%80"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 一阶语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 真值与模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%95%B4%E6%B6%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">逻辑蕴涵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95-1"><span class="toc-number">4.3.</span> <span class="toc-text">2.3 解析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%BB%8E%E8%AE%A1%E7%AE%97"><span class="toc-number">4.4.</span> <span class="toc-text">2.4 演绎计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E5%AE%8C%E5%A4%87%E6%80%A7%E7%90%86%E8%AE%BA"><span class="toc-number">4.5.</span> <span class="toc-text">2.5 可靠性与完备性理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.6.</span> <span class="toc-text">2.6 理论的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A7%A3%E9%87%8A%E4%B8%8D%E8%80%83"><span class="toc-number">4.7.</span> <span class="toc-text">2.7 理论之间的解释（不考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">3. 不可判定性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">5.1.</span> <span class="toc-text">3.0 数论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E7%9A%84%E5%AD%90%E7%90%86%E8%AE%BA"><span class="toc-number">5.2.</span> <span class="toc-text">3.3 数论的子理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%99%E8%BF%B0%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">叙述题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/11/2025%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="2025软件安全期末复习">2025软件安全期末复习</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/07/2025%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="2025数理逻辑期末复习">2025数理逻辑期末复习</a><time datetime="2025-01-06T16:00:00.000Z" title="发表于 2025-01-07 00:00:00">2025-01-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/15/2024%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="2024软件系统设计期末复习">2024软件系统设计期末复习</a><time datetime="2024-07-14T16:00:00.000Z" title="发表于 2024-07-15 00:00:00">2024-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/06/2024%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="2024软件质量管理期末复习">2024软件质量管理期末复习</a><time datetime="2024-07-05T16:00:00.000Z" title="发表于 2024-07-06 00:00:00">2024-07-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E5%90%8A%E6%88%91%E7%9A%84%E8%A3%A4%E5%AD%90/" title="吊我的裤子">吊我的裤子</a><time datetime="2024-06-28T16:00:00.000Z" title="发表于 2024-06-29 00:00:00">2024-06-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Chunchia Wang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23lipGb2DQkRK6VkDe',
      clientSecret: '16fd173d7022be11562011dc97f4f654941f7f77',
      repo: 'wangchunchia.github.io',
      owner: 'wangchunchia',
      admin: ['wangchunchia'],
      id: '12f0da052ae12c78213187c9f865ea4a',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>